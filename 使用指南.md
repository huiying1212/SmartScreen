# 安卓用户行为数据收集器使用指南

## 📋 **前置要求**

### 系统要求
- Android 6.0 (API 23) 及以上
- 支持蓝牙4.0+、GPS定位
- 加速度计和陀螺仪传感器
- 至少200MB可用存储空间

### 开发环境
- Android Studio 4.0+
- Gradle 6.0+
- Java 8+

## 🛠 **安装部署**

### 1. 项目导入
```bash
# 克隆或下载项目文件
# 在Android Studio中打开项目
File → Open → 选择项目文件夹
```

### 2. 依赖配置
在`app/build.gradle`中添加：
```gradle
dependencies {
    implementation 'androidx.core:core:1.8.0'
    implementation 'org.json:json:20210307'
    // 其他必要依赖已在代码中声明
}
```

### 3. 编译安装
```bash
# 连接安卓设备或启动模拟器
# 编译并安装应用
./gradlew installDebug
```

## 🎯 **使用方法**

### 方法一：完整集成使用

```java
public class MainActivity extends AppCompatActivity {
    private AndroidDataCollector collector;
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        // 1. 创建数据收集器实例
        collector = new AndroidDataCollector();
        
        // 2. 开始数据收集
        startDataCollection();
    }
    
    private void startDataCollection() {
        // 获取完整上下文数据
        JSONObject contextData = collector.getCompleteContextData();
        
        // 处理收集到的数据
        processCollectedData(contextData);
    }
    
    private void processCollectedData(JSONObject data) {
        try {
            // 提取各种数据类型
            long timestamp = data.getLong("timestamp");
            String dateTime = data.getString("date_time");
            
            JSONObject location = data.getJSONObject("location");
            double latitude = location.getDouble("latitude");
            double longitude = location.getDouble("longitude");
            
            JSONObject activity = data.getJSONObject("activity");
            String activityType = activity.getString("activity");
            float confidence = activity.getFloat("confidence");
            
            // 使用数据进行后续处理
            Log.d("DataCollector", "位置: " + latitude + ", " + longitude);
            Log.d("DataCollector", "活动: " + activityType + " (置信度: " + confidence + ")");
            
        } catch (JSONException e) {
            e.printStackTrace();
        }
    }
}
```

### 方法二：模块化使用

```java
// 仅使用活动识别
ActivityRecognizer activityRecognizer = new ActivityRecognizer(this);
JSONObject activityInfo = activityRecognizer.getActivityInfo();

// 仅使用屏幕内容收集
ScreenContentCollector screenCollector = new ScreenContentCollector(this);
screenCollector.startCollection();
JSONArray screenContent = screenCollector.getRecentScreenContent();
```

## ⚙️ **权限配置**

### 1. 基本权限自动申请
应用启动时会自动申请以下权限：
- 位置权限 (ACCESS_FINE_LOCATION)
- 存储权限 (WRITE_EXTERNAL_STORAGE)
- 蓝牙权限 (BLUETOOTH)
- 日历权限 (READ_CALENDAR)

### 2. 手动启用无障碍服务
屏幕内容收集需要用户手动启用：

```
设置 → 辅助功能 → 已安装的服务 → 
找到"数据收集器" → 开启服务
```

### 3. 电池优化设置
为确保后台正常运行：

```
设置 → 电池 → 电池优化 → 
找到应用 → 设置为"不优化"
```

## 📊 **数据访问**

### 实时数据获取
```java
// 获取当前完整上下文
JSONObject currentContext = collector.getCompleteContextData();

// 获取特定时间范围的屏幕内容
long startTime = System.currentTimeMillis() - 3600000; // 1小时前
long endTime = System.currentTimeMillis();
JSONArray screenData = screenCollector.getScreenContentInTimeRange(startTime, endTime);
```

### 文件数据读取
```java
// 数据自动保存到外部存储
File dataDir = getExternalFilesDir(null);
File[] dataFiles = dataDir.listFiles((dir, name) -> name.startsWith("context_data_"));

for (File file : dataFiles) {
    try {
        String jsonContent = readFileContent(file);
        JSONObject data = new JSONObject(jsonContent);
        // 处理历史数据
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```

## 🔄 **定时数据收集**

### 设置自动收集
```java
public class AutoDataCollector {
    private Timer timer;
    private AndroidDataCollector collector;
    
    public void startPeriodicCollection(int intervalMinutes) {
        timer = new Timer();
        timer.scheduleAtFixedRate(new TimerTask() {
            @Override
            public void run() {
                JSONObject data = collector.getCompleteContextData();
                saveDataToDatabase(data); // 保存到数据库
                uploadDataToServer(data); // 上传到服务器
            }
        }, 0, intervalMinutes * 60 * 1000);
    }
    
    public void stopCollection() {
        if (timer != null) {
            timer.cancel();
        }
    }
}
```

## 🔍 **数据分析示例**

### 活动模式分析
```java
public class ActivityAnalyzer {
    public void analyzeUserActivity(List<JSONObject> contextData) {
        Map<String, Integer> activityCount = new HashMap<>();
        
        for (JSONObject data : contextData) {
            try {
                JSONObject activity = data.getJSONObject("activity");
                String activityType = activity.getString("activity");
                activityCount.put(activityType, 
                    activityCount.getOrDefault(activityType, 0) + 1);
            } catch (JSONException e) {
                e.printStackTrace();
            }
        }
        
        // 输出活动统计
        for (Map.Entry<String, Integer> entry : activityCount.entrySet()) {
            Log.d("Analysis", "活动: " + entry.getKey() + ", 次数: " + entry.getValue());
        }
    }
}
```

### 位置轨迹分析
```java
public class LocationAnalyzer {
    public void analyzeLocationPattern(List<JSONObject> contextData) {
        List<LatLng> locations = new ArrayList<>();
        
        for (JSONObject data : contextData) {
            try {
                JSONObject location = data.getJSONObject("location");
                double lat = location.getDouble("latitude");
                double lng = location.getDouble("longitude");
                locations.add(new LatLng(lat, lng));
            } catch (JSONException e) {
                e.printStackTrace();
            }
        }
        
        // 计算移动距离、常用地点等
        analyzeMovementPatterns(locations);
    }
}
```

## 🛡️ **隐私和安全**

### 数据本地化
```java
// 确保数据只在本地处理
public class PrivacyManager {
    public static void enablePrivacyMode(AndroidDataCollector collector) {
        // 禁用网络上传
        // 启用数据脱敏
        // 定期清理历史数据
    }
    
    public static void anonymizeData(JSONObject data) {
        try {
            // 移除精确位置信息，只保留大致区域
            JSONObject location = data.getJSONObject("location");
            location.remove("latitude");
            location.remove("longitude");
            
            // 脱敏屏幕内容
            JSONArray screenContent = data.getJSONArray("screen_content");
            for (int i = 0; i < screenContent.length(); i++) {
                JSONObject screen = screenContent.getJSONObject(i);
                String content = screen.getString("content");
                screen.put("content", maskSensitiveInfo(content));
            }
        } catch (JSONException e) {
            e.printStackTrace();
        }
    }
}
```

## 🐛 **常见问题**

### 1. 权限被拒绝
```java
@Override
public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
    if (requestCode == LOCATION_PERMISSION_REQUEST) {
        if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
            // 权限获得，继续操作
            startDataCollection();
        } else {
            // 权限被拒绝，显示说明
            showPermissionExplanation();
        }
    }
}
```

### 2. 屏幕内容收集失败
- 检查无障碍服务是否启用
- 确认应用有足够的系统权限
- 重启应用或重新安装

### 3. 活动识别不准确
```java
// 调整识别参数
ActivityRecognizer recognizer = new ActivityRecognizer(this);
// 可以修改阈值参数来提高准确性
```

### 4. 数据存储空间不足
```java
public void cleanupOldData() {
    File dataDir = getExternalFilesDir(null);
    long cutoffTime = System.currentTimeMillis() - (7 * 24 * 60 * 60 * 1000); // 7天前
    
    File[] files = dataDir.listFiles();
    for (File file : files) {
        if (file.lastModified() < cutoffTime) {
            file.delete();
        }
    }
}
```

## 📈 **性能优化**

### 1. 内存优化
```java
// 定期清理内存中的数据队列
screenCollector.clearQueue();

// 限制数据收集频率
collector.setCollectionInterval(60000); // 1分钟间隔
```

### 2. 电池优化
```java
// 在屏幕关闭时暂停收集
@Override
protected void onPause() {
    super.onPause();
    collector.pauseCollection();
}

@Override
protected void onResume() {
    super.onResume();
    collector.resumeCollection();
}
```

## 📞 **技术支持**

如果遇到问题，可以：
1. 查看应用日志：`adb logcat | grep DataCollector`
2. 检查权限设置
3. 确认设备兼容性
4. 重新安装应用

## 🔄 **更新和维护**

定期更新应用以获得：
- 新功能支持
- 性能优化
- 安全补丁
- 兼容性改进

---

**注意**: 使用本应用前请确保已获得用户明确同意，并遵守当地隐私法规。 